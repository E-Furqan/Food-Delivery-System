
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>AuthClient: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/E-Furqan/Food-Delivery-System/Client/AuthClient/authClient.go (0.0%)</option>
				
				<option value="file1">github.com/E-Furqan/Food-Delivery-System/Client/OrderClient/orderClient.go (0.0%)</option>
				
				<option value="file2">github.com/E-Furqan/Food-Delivery-System/Controllers/ItemController/ItemController.go (0.0%)</option>
				
				<option value="file3">github.com/E-Furqan/Food-Delivery-System/Controllers/RestaurantController/restaurantController.go (0.0%)</option>
				
				<option value="file4">github.com/E-Furqan/Food-Delivery-System/DatabaseConfig/config.go (0.0%)</option>
				
				<option value="file5">github.com/E-Furqan/Food-Delivery-System/EnviormentVariable/env.go (40.0%)</option>
				
				<option value="file6">github.com/E-Furqan/Food-Delivery-System/Middleware/middleware.go (0.0%)</option>
				
				<option value="file7">github.com/E-Furqan/Food-Delivery-System/Models/transitionModel.go (0.0%)</option>
				
				<option value="file8">github.com/E-Furqan/Food-Delivery-System/Repositories/TestRepositories/ConfigTestDatabase.go (88.9%)</option>
				
				<option value="file9">github.com/E-Furqan/Food-Delivery-System/Repositories/database.go (70.8%)</option>
				
				<option value="file10">github.com/E-Furqan/Food-Delivery-System/Routes/routes.go (0.0%)</option>
				
				<option value="file11">github.com/E-Furqan/Food-Delivery-System/Utils/utils.go (9.1%)</option>
				
				<option value="file12">github.com/E-Furqan/Food-Delivery-System/main.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package AuthClient

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"

        model "github.com/E-Furqan/Food-Delivery-System/Models"
)

type AuthClient struct {
        model.AuthClientEnv
}

func NewClient(env model.AuthClientEnv) *AuthClient <span class="cov0" title="0">{
        return &amp;AuthClient{
                AuthClientEnv: env,
        }
}</span>

func (client *AuthClient) GenerateToken(input model.RestaurantClaim) (*model.Tokens, error) <span class="cov0" title="0">{

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling input: %v", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s%s%s", client.AuthClientEnv.BASE_URL, client.AuthClientEnv.AUTH_PORT, client.AuthClientEnv.GENERATE_TOKEN_URL)
        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %v", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("received non-200 response: %v", resp.Status)
        }</span>

        <span class="cov0" title="0">var tokens model.Tokens
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokens); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;tokens, nil</span>
}

func (client *AuthClient) RefreshToken(input model.RefreshToken) (*model.Tokens, error) <span class="cov0" title="0">{

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling input: %v", err)
        }</span>
        <span class="cov0" title="0">url := fmt.Sprintf("%s%s%s", client.AuthClientEnv.BASE_URL, client.AuthClientEnv.AUTH_PORT, client.AuthClientEnv.REFRESH_TOKEN_URL)

        req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %v", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("received non-200 response: %v", resp.Status)
        }</span>

        <span class="cov0" title="0">var tokens model.Tokens
        if err := json.NewDecoder(resp.Body).Decode(&amp;tokens); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;tokens, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package OrderClient

import (
        "bytes"
        "encoding/json"
        "fmt"
        "net/http"

        model "github.com/E-Furqan/Food-Delivery-System/Models"
)

type OrderClient struct {
        model.OrderClientEnv
}

func NewClient(env model.OrderClientEnv) *OrderClient <span class="cov0" title="0">{
        return &amp;OrderClient{
                OrderClientEnv: env,
        }
}</span>

func (OrderClient *OrderClient) UpdateOrderStatus(input model.OrderDetails, token string) error <span class="cov0" title="0">{

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error marshaling input: %v", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s%s%s", OrderClient.OrderClientEnv.BASE_URL, OrderClient.OrderClientEnv.ORDER_PORT, OrderClient.OrderClientEnv.UPDATE_ORDER_STATUS_URL)
        req, err := http.NewRequest("PATCH", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+token)

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error sending request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("received non-200 response: %v", resp.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (OrderClient *OrderClient) ViewRestaurantOrders(input model.Input, token string) (*[]model.OrderDetails, error) <span class="cov0" title="0">{

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling input: %v", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s%s%s", OrderClient.OrderClientEnv.BASE_URL, OrderClient.OrderClientEnv.ORDER_PORT, OrderClient.OrderClientEnv.RESTAURANT_ORDERS_URL)
        req, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+token)

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("received non-200 response: %v", resp.Status)
        }</span>

        <span class="cov0" title="0">var orders []model.OrderDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;orders); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;orders, nil</span>
}

func (OrderClient *OrderClient) ViewOrdersDetails(input model.OrderDetails, token string) (*model.OrderDetails, error) <span class="cov0" title="0">{

        jsonData, err := json.Marshal(input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshaling input: %v", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s%s%s", OrderClient.OrderClientEnv.BASE_URL, OrderClient.OrderClientEnv.ORDER_PORT, OrderClient.OrderClientEnv.VIEW_ORDER_DETAIL_URL)
        req, err := http.NewRequest("GET", url, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error creating request: %v", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Authorization", "Bearer "+token)

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error sending request: %v", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("received non-200 response: %v", resp.Status)
        }</span>

        <span class="cov0" title="0">var orders model.OrderDetails
        if err := json.NewDecoder(resp.Body).Decode(&amp;orders); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding response: %v", err)
        }</span>

        <span class="cov0" title="0">return &amp;orders, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package ItemController

import (
        "net/http"

        model "github.com/E-Furqan/Food-Delivery-System/Models"
        database "github.com/E-Furqan/Food-Delivery-System/Repositories"
        utils "github.com/E-Furqan/Food-Delivery-System/Utils"
        "github.com/gin-gonic/gin"
)

type ItemController struct {
        Repo *database.Repository
}

func NewController(repo *database.Repository) *ItemController <span class="cov0" title="0">{
        return &amp;ItemController{Repo: repo}
}</span>

func (ItemController *ItemController) AddItemsInMenu(c *gin.Context) <span class="cov0" title="0">{

        RestaurantID, err := utils.Verification(c)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant not authenticated"})
                return
        }</span>
        <span class="cov0" title="0">var Restaurant model.Restaurant
        err = ItemController.Repo.GetRestaurant("restaurant_id", RestaurantID, &amp;Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">var NewItemData model.Item

        if err = c.ShouldBindJSON(&amp;NewItemData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">NewItemData.RestaurantId = Restaurant.RestaurantId
        if err = ItemController.Repo.AddItemToRestaurantMenu(NewItemData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Item added to menu successfully"})</span>
}

func (ItemController *ItemController) DeleteItemsFromMenu(c *gin.Context) <span class="cov0" title="0">{

        RestaurantID, err := utils.Verification(c)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var Restaurant model.Restaurant
        err = ItemController.Repo.GetRestaurant("restaurant_id", RestaurantID, &amp;Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">var DeleteItemId model.Input

        if err = c.ShouldBindJSON(&amp;DeleteItemId); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err})
                return
        }</span>

        <span class="cov0" title="0">if err = ItemController.Repo.RemoveItem(Restaurant.RestaurantId, DeleteItemId.ItemId); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Item deleted from the restaurant menu"})</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package RestaurantController

import (
        "net/http"
        "strings"

        "github.com/E-Furqan/Food-Delivery-System/Client/AuthClient"
        "github.com/E-Furqan/Food-Delivery-System/Client/OrderClient"
        model "github.com/E-Furqan/Food-Delivery-System/Models"
        database "github.com/E-Furqan/Food-Delivery-System/Repositories"
        utils "github.com/E-Furqan/Food-Delivery-System/Utils"
        "github.com/gin-gonic/gin"
)

type RestaurantController struct {
        Repo        *database.Repository
        OrderClient *OrderClient.OrderClient
        AuthClient  *AuthClient.AuthClient
}

func NewController(repo *database.Repository, OrderClient *OrderClient.OrderClient, AuthClient *AuthClient.AuthClient) *RestaurantController <span class="cov0" title="0">{
        return &amp;RestaurantController{
                Repo:        repo,
                OrderClient: OrderClient,
                AuthClient:  AuthClient,
        }
}</span>

func (ctrl *RestaurantController) Register(c *gin.Context) <span class="cov0" title="0">{

        var registrationData model.Restaurant

        if err := c.ShouldBindJSON(&amp;registrationData); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">err := ctrl.Repo.CreateRestaurant(&amp;registrationData)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, registrationData)</span>
}

func (ctrl *RestaurantController) Login(c *gin.Context) <span class="cov0" title="0">{

        var input model.Credentials
        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error while binding": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var Restaurant model.Restaurant
        err := ctrl.Repo.GetRestaurant("restaurant_email", input.Email, &amp;Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">if Restaurant.Password != input.Password </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid password"})
                return
        }</span>

        <span class="cov0" title="0">var RestaurantClaim model.RestaurantClaim
        RestaurantClaim.ClaimId = Restaurant.RestaurantId
        RestaurantClaim.Role = "Restaurant"

        tokens, err := ctrl.AuthClient.GenerateToken(RestaurantClaim)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "access token":  tokens.AccessToken,
                "refresh token": tokens.RefreshToken,
                "expires at":    tokens.Expiration,
        })</span>
}

func (ctrl *RestaurantController) GetAllRestaurants(c *gin.Context) <span class="cov0" title="0">{

        var restaurants []model.Restaurant

        if err := ctrl.Repo.GetAllRestaurants(&amp;restaurants); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err})
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, restaurants)</span>
}

func (ctrl *RestaurantController) UpdateRestaurantStatus(c *gin.Context) <span class="cov0" title="0">{
        RestaurantID, err := utils.Verification(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var Restaurant model.Restaurant
        err = ctrl.Repo.GetRestaurant("restaurant_id", RestaurantID, &amp;Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid credentials"})
                return
        }</span>

        <span class="cov0" title="0">var input model.Input

        if err = c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error while binding": err})
                return
        }</span>

        <span class="cov0" title="0">if err = ctrl.Repo.UpdateRestaurantStatus(&amp;Restaurant, input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error while updating": err})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"Message": "Restaurant status updated"})</span>
}

func (ctrl *RestaurantController) ViewMenu(c *gin.Context) <span class="cov0" title="0">{

        var Items []model.Item
        var combinedInput model.CombinedInput

        if err := c.ShouldBindJSON(&amp;combinedInput); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error binding": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">var Restaurant model.Restaurant
        err := ctrl.Repo.GetRestaurant("restaurant_id", combinedInput.RestaurantId, &amp;Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant does not exist"})
                return
        }</span>

        <span class="cov0" title="0">Items, err = ctrl.Repo.LoadItems(combinedInput.RestaurantId, combinedInput.ColumnName, combinedInput.OrderType)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error load item": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if len(Items) &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, "No items present in the restaurant")
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, Items)</span>
}

func (ctrl *RestaurantController) UpdateOrderStatus(c *gin.Context) <span class="cov0" title="0">{

        RestaurantID, err := utils.Verification(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">RestaurantIDValue := RestaurantID.(uint)

        var order model.OrderDetails
        if err := c.ShouldBindJSON(&amp;order); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, "Error while binding order status")
                return
        }</span>
        <span class="cov0" title="0">order.RestaurantId = RestaurantIDValue

        token, err := utils.GetAuthToken(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.GenerateResponse(http.StatusUnauthorized, c, "error", err.Error(), "", nil)
                return
        }</span>

        <span class="cov0" title="0">if err := ctrl.OrderClient.UpdateOrderStatus(order, token); err != nil </span><span class="cov0" title="0">{
                utils.GenerateResponse(http.StatusBadRequest, c, "Message", "Post request failed", "Error", err.Error())
                return
        }</span>

        <span class="cov0" title="0">utils.GenerateResponse(http.StatusOK, c, "Message", "Order status updated", "", "")</span>
}

func (ctrl *RestaurantController) ViewRestaurantOrders(c *gin.Context) <span class="cov0" title="0">{
        RestaurantID, err := utils.Verification(c)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant not authenticated"})
                return
        }</span>

        <span class="cov0" title="0">var Restaurant model.Restaurant
        err = ctrl.Repo.GetRestaurant("restaurant_id", RestaurantID, &amp;Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Restaurant does not exists"})
                return
        }</span>

        <span class="cov0" title="0">token, err := utils.GetAuthToken(c)
        if err != nil </span><span class="cov0" title="0">{
                utils.GenerateResponse(http.StatusUnauthorized, c, "error", err.Error(), "", nil)
                return
        }</span>

        <span class="cov0" title="0">var restaurantId model.Input
        restaurantId.RestaurantId = Restaurant.RestaurantId
        Orders, err := ctrl.OrderClient.ViewRestaurantOrders(restaurantId, token)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var filter model.OrderFilter
        if err := c.ShouldBindJSON(&amp;filter); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var filteredOrders []model.OrderDetails
        for _, order := range *Orders </span><span class="cov0" title="0">{
                if filter.Filter == "all" || filter.Filter == "" || strings.EqualFold(order.OrderStatus, filter.Filter) </span><span class="cov0" title="0">{
                        filteredOrders = append(filteredOrders, order)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "Restaurant orders: ": filteredOrders,
        })</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "log"

        model "github.com/E-Furqan/Food-Delivery-System/Models"
        _ "github.com/golang-migrate/migrate/v4/database/postgres"
        _ "github.com/golang-migrate/migrate/v4/source/file"
        "github.com/joho/godotenv"
        _ "github.com/lib/pq"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

type DatabaseConfig struct {
        model.DatabaseEnv
}

func NewDatabase(env model.DatabaseEnv) *DatabaseConfig <span class="cov0" title="0">{
        return &amp;DatabaseConfig{
                DatabaseEnv: env,
        }
}</span>

var DB *gorm.DB

func (DatabaseConfig *DatabaseConfig) Connection() *gorm.DB <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error loading .env file: %v", err)
        }</span>

        <span class="cov0" title="0">var connection_string = fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                DatabaseConfig.DatabaseEnv.DATABASE_HOST, DatabaseConfig.DatabaseEnv.DATABASE_PORT, DatabaseConfig.DatabaseEnv.DATABASE_USER,
                DatabaseConfig.DatabaseEnv.DATABASE_PASSWORD, DatabaseConfig.DatabaseEnv.DATABASE_NAME)

        log.Println(connection_string)
        DB, err = gorm.Open(postgres.Open(connection_string), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>

        // err = DB.AutoMigrate(&amp;model.Item{})
        // if err != nil {
        //         log.Fatalf("Failed to migrate database: %v", err)
        // }

        // err = DB.AutoMigrate(&amp;model.Restaurant{})
        // if err != nil {
        //         log.Fatalf("Failed to migrate database: %v", err)
        // }

        <span class="cov0" title="0">log.Println("Database connection established")

        return DB</span>
}

// func (DatabaseConfig *DatabaseConfig) RunMigrations() {
//         // Use Docker service name for the database connection
//         var connection_string = fmt.Sprintf("postgres://%s:%s@%s:%d/%s?sslmode=disable",
//                 DatabaseConfig.DatabaseEnv.DATABASE_USER,
//                 DatabaseConfig.DatabaseEnv.DATABASE_PASSWORD,
//                 DatabaseConfig.DatabaseEnv.DATABASE_HOST,
//                 DatabaseConfig.DatabaseEnv.DATABASE_PORT,
//                 DatabaseConfig.DatabaseEnv.DATABASE_NAME)

//         // absPath, err := filepath.Abs("./Migration")
//         // if err != nil {
//         //         log.Printf("Error getting absolute path: %v", err)
//         // }
//         absPath := "/app/Migration"
//         // absPath = "file://" + absPath

//         log.Printf("Using migration path: %s", absPath)
//         log.Printf("Using connectionString: %s", connection_string)

//         m, err := migrate.New(
//                 absPath,
//                 connection_string,
//         )
//         if err != nil {
//                 log.Fatalf("Migration instance error: %v", err)
//         }

//         err = m.Up()
//         if err != nil &amp;&amp; err != migrate.ErrNoChange {
//                 log.Fatalf("Migration failed: %v", err)
//         }

//         log.Println("Migrations applied successfully")
// }
</pre>
		
		<pre class="file" id="file5" style="display: none">package environmentVariable

import (
        "log"
        "strconv"

        model "github.com/E-Furqan/Food-Delivery-System/Models"
        utils "github.com/E-Furqan/Food-Delivery-System/Utils"
        "github.com/joho/godotenv"
)

func ReadDatabaseEnv() model.DatabaseEnv <span class="cov8" title="1">{
        var envVar model.DatabaseEnv
        err := godotenv.Load()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error loading .env file: %v", err)
        }</span>

        <span class="cov8" title="1">envVar.DATABASE_HOST = utils.GetEnv("DATABASE_HOST", "db")
        envVar.DATABASE_USER = utils.GetEnv("DATABASE_USER", "furqan")
        envVar.DATABASE_PASSWORD = utils.GetEnv("DATABASE_PASSWORD", "furqan")
        envVar.DATABASE_NAME = utils.GetEnv("DATABASE_NAME", "Restaurant")
        portStr := utils.GetEnv("PORT", "5432")
        envVar.DATABASE_PORT, err = strconv.Atoi(portStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error converting PORT to integer: %v", err)
                envVar.DATABASE_PORT = 5432
        }</span>
        <span class="cov8" title="1">return envVar</span>
}

func ReadOrderClientEnv() model.OrderClientEnv <span class="cov0" title="0">{
        var envVar model.OrderClientEnv
        envVar.BASE_URL = utils.GetEnv("BASE_URL", "http://localhost")
        envVar.UPDATE_ORDER_STATUS_URL = utils.GetEnv("UPDATE_ORDER_STATUS_URL", "/order/update/status")
        envVar.ORDER_PORT = utils.GetEnv("ORDER_PORT", ":8081")
        envVar.RESTAURANT_ORDERS_URL = utils.GetEnv("RESTAURANT_ORDERS_URL", "/order/view/orders")
        envVar.VIEW_ORDER_DETAIL_URL = utils.GetEnv("VIEW_ORDER_DETAIL_URL", "/order/view/order")
        return envVar
}</span>

func ReadAuthClientEnv() model.AuthClientEnv <span class="cov0" title="0">{
        var envVar model.AuthClientEnv
        envVar.AUTH_PORT = utils.GetEnv("AUTH_PORT", ":8084")
        envVar.GENERATE_TOKEN_URL = utils.GetEnv("GENERATE_TOKEN_URL", "/auth/generate/token")
        envVar.REFRESH_TOKEN_URL = utils.GetEnv("REFRESH_TOKEN_URL", "/auth/refresh/token")
        return envVar
}</span>

func ReadMiddlewareEnv() model.MiddlewareEnv <span class="cov0" title="0">{
        var envVar model.MiddlewareEnv
        envVar.JWT_SECRET = utils.GetEnv("JWT_SECRET", "Furqan")
        envVar.REFRESH_TOKEN_SECRET = utils.GetEnv("REFRESH_TOKEN_SECRET", "Ali")
        return envVar
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package Middleware

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/E-Furqan/Food-Delivery-System/Client/AuthClient"
        model "github.com/E-Furqan/Food-Delivery-System/Models"
        "github.com/dgrijalva/jwt-go"
        "github.com/gin-gonic/gin"
)

type Middleware struct {
        AuthClient *AuthClient.AuthClient
        envVar     *model.MiddlewareEnv
}

func NewMiddleware(AuthClient *AuthClient.AuthClient, envVar *model.MiddlewareEnv) *Middleware <span class="cov0" title="0">{
        return &amp;Middleware{
                AuthClient: AuthClient,
                envVar:     envVar,
        }
}</span>

func (middle *Middleware) AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tokenString := c.GetHeader("Authorization")
                if tokenString == "" || !strings.HasPrefix(tokenString, "Bearer ") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization token required"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString = strings.TrimPrefix(tokenString, "Bearer ")

                claims := &amp;model.RestaurantClaim{}
                token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(middle.envVar.JWT_SECRET), nil
                }</span>)
                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{

                        c.JSON(http.StatusUnauthorized, gin.H{"Error": fmt.Sprint("Invalid token")})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("RestaurantID", claims.ClaimId)
                c.Next()</span>
        }
}

func (middle *Middleware) RefreshToken(c *gin.Context) <span class="cov0" title="0">{

        var input model.RefreshToken

        if err := c.ShouldBindJSON(&amp;input); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var refreshClaim model.RefreshToken
        refreshClaim.RefreshToken = input.RefreshToken
        refreshClaim.Role = "Restaurant"
        tokens, err := middle.AuthClient.RefreshToken(refreshClaim)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Could not generate token"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "access token":  tokens.AccessToken,
                "refresh token": tokens.RefreshToken,
                "expires at":    tokens.Expiration,
        })</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package model

func GetOrderTransitions() map[string]string <span class="cov0" title="0">{
        return map[string]string{
                "order placed": "Accepted",
                "Accepted":     "In process",
                "In process":   "Waiting For Delivery Driver",
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package database_test

import (
        "fmt"
        "log"

        environmentVariable "github.com/E-Furqan/Food-Delivery-System/EnviormentVariable"
        "github.com/joho/godotenv"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

var DB *gorm.DB

func TestDatabaseConnection() *gorm.DB <span class="cov8" title="1">{
        envVar := environmentVariable.ReadDatabaseEnv()

        err := godotenv.Load()
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error loading .env file: %v", err)
        }</span>

        <span class="cov8" title="1">var connection_string = fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=disable",
                "0.0.0.0", 5432, envVar.DATABASE_USER, envVar.DATABASE_PASSWORD, "testrestaurant")

        DB, err = gorm.Open(postgres.Open(connection_string), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect to database: %v", err)
        }</span>
        <span class="cov8" title="1">return DB</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package database

import (
        "fmt"
        "log"

        model "github.com/E-Furqan/Food-Delivery-System/Models"
        "gorm.io/gorm"
)

type Repository struct {
        DB *gorm.DB
}

func NewRepository(db *gorm.DB) *Repository <span class="cov0" title="0">{
        return &amp;Repository{
                DB: db,
        }
}</span>

func (repo *Repository) CreateRestaurant(Restaurant *model.Restaurant) error <span class="cov8" title="1">{

        tx := repo.DB.Begin()

        result := tx.Create(Restaurant)
        if result.Error != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return result.Error
        }</span>

        <span class="cov8" title="1">log.Print(Restaurant)
        return tx.Commit().Error</span>
}

func (repo *Repository) GetRestaurant(columnName string, findParameter interface{}, Restaurant *model.Restaurant) error <span class="cov8" title="1">{
        tx := repo.DB.Begin()

        err := repo.DB.Where(columnName+" = ?", findParameter).First(Restaurant).Error
        if err != nil </span><span class="cov8" title="1">{
                log.Printf("Error : %s", err)
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">err = repo.LoadRestaurantWithItems(Restaurant)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov8" title="1">return tx.Commit().Error</span>
}

func (repo *Repository) LoadRestaurantWithItems(Restaurant *model.Restaurant) error <span class="cov8" title="1">{

        tx := repo.DB.Begin()

        err := tx.Model(Restaurant).Association("Items").Find(&amp;Restaurant.Items)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error loading Restaurant with Item: %v", err)
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit().Error</span>
}

func (repo *Repository) LoadItems(RestaurantID uint, columnName string, order string) ([]model.Item, error) <span class="cov8" title="1">{
        if columnName == "" </span><span class="cov8" title="1">{
                columnName = "restaurant_id"
        }</span>
        <span class="cov8" title="1">if order == "" </span><span class="cov8" title="1">{
                order = "asc"
        }</span>

        <span class="cov8" title="1">var ItemData []model.Item
        tx := repo.DB.Begin()

        err := tx.
                Where("restaurant_id = ?", RestaurantID).
                Order(fmt.Sprintf("%s %s", columnName, order)).
                Find(&amp;ItemData).Error

        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return nil, err
        }</span>

        <span class="cov8" title="1">return ItemData, tx.Commit().Error</span>
}

func (repo *Repository) AddItemToRestaurantMenu(newItem model.Item) error <span class="cov8" title="1">{

        tx := repo.DB.Begin()

        if err := tx.Create(&amp;newItem).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov8" title="1">return tx.Commit().Error</span>
}

func (repo *Repository) RemoveItem(restaurantId uint, itemId uint) error <span class="cov8" title="1">{
        tx := repo.DB.Begin()

        err := tx.Where("restaurant_id = ? AND item_id = ?", restaurantId, itemId).Delete(&amp;model.Item{}).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">err = tx.Where("item_id = ?", itemId).Delete(&amp;model.Item{}).Error
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>
        <span class="cov8" title="1">return tx.Commit().Error</span>
}

func (repo *Repository) GetAllRestaurants(restaurants *[]model.Restaurant) error <span class="cov8" title="1">{
        err := repo.DB.
                Where("restaurant_status != ?", "closed").
                Find(restaurants).Error

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (repo *Repository) UpdateRestaurantStatus(restaurant *model.Restaurant, input model.Input) error <span class="cov8" title="1">{

        tx := repo.DB.Begin()

        if err := tx.Model(restaurant).Update("restaurant_status", input.RestaurantStatus).Error; err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">err := repo.LoadRestaurantWithItems(restaurant)
        if err != nil </span><span class="cov0" title="0">{
                tx.Rollback()
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit().Error</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package route

import (
        "github.com/E-Furqan/Food-Delivery-System/Controllers/ItemController"
        "github.com/E-Furqan/Food-Delivery-System/Controllers/RestaurantController"
        "github.com/E-Furqan/Food-Delivery-System/Middleware"
        "github.com/gin-gonic/gin"
)

func Restaurant_routes(RestaurantController *RestaurantController.RestaurantController, ItemController *ItemController.ItemController, middleware *Middleware.Middleware, server *gin.Engine) <span class="cov0" title="0">{

        restaurantRoute := server.Group("/restaurant")
        restaurantRoute.POST("/register", RestaurantController.Register)
        restaurantRoute.POST("/login", RestaurantController.Login)
        restaurantRoute.POST("/refresh/token", middleware.RefreshToken)
        restaurantRoute.GET("/view/menu", RestaurantController.ViewMenu)
        restaurantRoute.GET("/get/restaurants", RestaurantController.GetAllRestaurants)
        restaurantRoute.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                restaurantRoute.PATCH("/update/order/status", RestaurantController.UpdateOrderStatus)
                restaurantRoute.POST("/add/items", ItemController.AddItemsInMenu)
                restaurantRoute.DELETE("/delete/items", ItemController.DeleteItemsFromMenu)
                restaurantRoute.PATCH("/update/status", RestaurantController.UpdateRestaurantStatus)
                restaurantRoute.GET("/view/restaurant/orders", RestaurantController.ViewRestaurantOrders)
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package utils

import (
        "fmt"
        "os"
        "strings"

        "github.com/gin-gonic/gin"
)

func Verification(c *gin.Context) (any, error) <span class="cov0" title="0">{
        RestaurantID, exists := c.Get("RestaurantID")
        if !exists </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("restaurant id does not exist")
        }</span>

        <span class="cov0" title="0">RestaurantID, ok := RestaurantID.(uint)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid restaurant id")
        }</span>
        <span class="cov0" title="0">return RestaurantID, nil</span>
}

func GenerateResponse(httpStatusCode int, c *gin.Context, title1 string, message1 string, title2 string, input interface{}) <span class="cov0" title="0">{
        response := gin.H{
                title1: message1,
        }

        if title2 != "" &amp;&amp; input != nil </span><span class="cov0" title="0">{
                response[title2] = input
        }</span>

        <span class="cov0" title="0">c.JSON(httpStatusCode, response)</span>
}

func GetEnv(key string, defaultVal string) string <span class="cov8" title="1">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov8" title="1">return defaultVal</span>
}

func GetAuthToken(c *gin.Context) (string, error) <span class="cov0" title="0">{
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("authorization token not provided")
        }</span>
        <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid authorization header format")
        }</span>
        <span class="cov0" title="0">token := tokenParts[1]
        return token, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package main

import (
        "github.com/E-Furqan/Food-Delivery-System/Client/AuthClient"
        "github.com/E-Furqan/Food-Delivery-System/Client/OrderClient"
        "github.com/E-Furqan/Food-Delivery-System/Controllers/ItemController"
        "github.com/E-Furqan/Food-Delivery-System/Controllers/RestaurantController"
        config "github.com/E-Furqan/Food-Delivery-System/DatabaseConfig"
        environmentVariable "github.com/E-Furqan/Food-Delivery-System/EnviormentVariable"
        "github.com/E-Furqan/Food-Delivery-System/Middleware"
        database "github.com/E-Furqan/Food-Delivery-System/Repositories"
        route "github.com/E-Furqan/Food-Delivery-System/Routes"
        "github.com/gin-gonic/gin"
)

func main() <span class="cov0" title="0">{
        DatabaseEnv := environmentVariable.ReadDatabaseEnv()
        OrderClientEnv := environmentVariable.ReadOrderClientEnv()
        AuthClientEnv := environmentVariable.ReadAuthClientEnv()
        MiddlewareEnv := environmentVariable.ReadMiddlewareEnv()

        databaseConfig := config.NewDatabase(DatabaseEnv)
        db := databaseConfig.Connection()

        OrdClient := OrderClient.NewClient(OrderClientEnv)
        AuthClient := AuthClient.NewClient(AuthClientEnv)

        repo := database.NewRepository(db)
        ctrl := RestaurantController.NewController(repo, OrdClient, AuthClient)
        ItemController := ItemController.NewController(repo)
        middle := Middleware.NewMiddleware(AuthClient, &amp;MiddlewareEnv)

        server := gin.Default()
        route.Restaurant_routes(ctrl, ItemController, middle, server)
        server.Run(":8082")
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
